# -*- coding: utf-8 -*-
"""T2 flujo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RRZj6SE4_TSE-DMUbdFkEq-ko9NXAOrK
"""

import pandas as pd
import networkx as nx
import numpy as np
import os

ruta1 = os.path.join('ubicacion_produccion.csv')
ruta2 = os.path.join("ubicacion_bodegas_adicionales.csv")
ruta3 = os.path.join("ubicacion_demanda.csv")

ubicacion_produccion = pd.read_csv(ruta1)
ubicacion_bodegas = pd.read_csv(ruta2)
ubicacion_demanda = pd.read_csv(ruta3)

# Se crea un DataFrame combinado con todos los nodos y ubicaciones
nodos_produccion = ubicacion_produccion[['id_nodo', 'x', 'y']].copy()
nodos_produccion['tipo'] = 'produccion'

nodos_bodegas = ubicacion_bodegas[['id_nodo', 'x', 'y']].copy()
nodos_bodegas['tipo'] = 'bodega'

nodos_demanda = ubicacion_demanda[['id_nodo', 'x', 'y']].copy()
nodos_demanda['tipo'] = 'demanda'

# Se combina en un solo DataFrame
nodos_totales = pd.concat([nodos_produccion, nodos_bodegas, nodos_demanda], ignore_index=True)

# Se crea un grafo para representar la red
grafo_vial = nx.Graph()

# Se añaden los nodos al grafo
for _, row in nodos_totales.iterrows():
    grafo_vial.add_node(row['id_nodo'], pos=(row['x'], row['y']), tipo=row['tipo'])

# Se añaden los vertices con distancia entre todos los nodos
for i, nodo_i in nodos_totales.iterrows():
    for j, nodo_j in nodos_totales.iterrows():
        if i < j:  # Evitar duplicados
            distancia = np.sqrt((nodo_i['x'] - nodo_j['x'])**2 + (nodo_i['y'] - nodo_j['y'])**2)
            grafo_vial.add_edge(nodo_i['id_nodo'], nodo_j['id_nodo'], weight=distancia)

# Se crea matriz de costos por transporte
nodos_relevantes = list(grafo_vial.nodes)
num_nodos = len(nodos_relevantes)
matriz_distancias = np.zeros((num_nodos, num_nodos))

# Se llena la matriz
for i, nodo_i in enumerate(nodos_relevantes):
    for j, nodo_j in enumerate(nodos_relevantes):
        if i != j:
            matriz_distancias[i, j] = nx.shortest_path_length(grafo_vial, source=nodo_i, target=nodo_j, weight='weight')

# Se define la constante de costo por unidad de distancia
c_tte = 1  # Puedes cambiar este valor según sea necesario

# Se calcula la matriz de costos basada en la matriz de distancias
matriz_costos = c_tte * matriz_distancias

# Se crea un DataFrame de la matriz de costos
matriz_costos_df = pd.DataFrame(matriz_costos, index=nodos_relevantes, columns=nodos_relevantes)

# Se muestra la matriz de costos
print("Matriz de Costos de Transporte entre Nodos:")
print(matriz_costos_df)